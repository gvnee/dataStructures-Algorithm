#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef vector< pair<int, int> > vpi;

#define sz(x) int((x).size())
#define pb push_back
#define ff first
#define ss second

const int MXN = 1e6;
int res[MXN] = {};

vpi merge(vpi a, vpi b){
  vpi c;
  int ai = 0, bi = 0;
  int aa = 0;

  while(ai < sz(a) && bi < sz(b)){
    if(a[ai].ff > b[bi].ff){
      c.pb(b[bi]);
      aa++;
      bi++;
    }
    else{
      res[a[ai].ss] += aa;
      c.pb(a[ai]);
      bi++;
    }
  }

  while(ai<sz(a)){
    res[a[ai].ss] += aa;
    c.pb(a[ai]);
    ai++;
  }
  while(bi<sz(b)){
    c.pb(b[bi]);
    bi++;
  }

  cout<<"{";
  for(auto i:a) cout<<i.ff<<" ";
  cout<<"} + {";
  for(auto i:b) cout<<i.ff<<" ";
  cout<<"} -> {";
  for(auto i:c) cout<<i.ff<<" ";
  cout<<"}\n";
  
  return c;
}

vpi mergeSort(vpi given){
  if(sz(given) == 1) return given;
  vpi a, b;
  a.assign(given.begin(), given.begin() + sz(given)/2);
  b.assign(given.begin() + sz(given)/2, given.end());

  return merge(mergeSort(a), mergeSort(b));
}

void f(){
  int n;
  cin>>n;
  vpi a;
  int t;
  for(int i = 0;i<n;i++){
    cin>>t;
    a.pb({t, i});
  }

  mergeSort(a);
  
  for(int i = 0;i<n;i++){
    cout<<res[i]<<" ";
  }
  cout<<"\n";
}

int main(){
  cin.tie(0); ios_base::sync_with_stdio(0);
  int t = 1;
  // cin>>t;
  while(t--) f();
  return 0;
}

// // Wrapper class for each and every value of the input array,
// // to store the original index position of each value, before we merge sort the array
// private class ArrayValWithOrigIdx {
//     int val;
//     int originalIdx;
    
//     public ArrayValWithOrigIdx(int val, int originalIdx) {
//         this.val = val;
//         this.originalIdx = originalIdx;
//     }
// }

// public List<Integer> countSmaller(int[] nums) {
//     if (nums == null || nums.length == 0) return new LinkedList<Integer>();
//     int n = nums.length;
//     int[] result = new int[n];
    
//     ArrayValWithOrigIdx[] newNums = new ArrayValWithOrigIdx[n];
//     for (int i = 0; i < n; ++i) newNums[i] = new ArrayValWithOrigIdx(nums[i], i);
        
//     mergeSortAndCount(newNums, 0, n - 1, result);
    
//     // notice we don't care about the sorted array after merge sort finishes.
//     // we only wanted the result counts, generated by running merge sort
//     List<Integer> resultList = new LinkedList<Integer>();
//     for (int i : result) resultList.add(i);
//     return resultList;
// }

// private void mergeSortAndCount(ArrayValWithOrigIdx[] nums, int start, int end, int[] result) {
//     if (start >= end) return;
    
//     int mid = (start + end) / 2;
//     mergeSortAndCount(nums, start, mid, result);
//     mergeSortAndCount(nums, mid + 1, end, result);
    
//     // left subarray start...mid
//     // right subarray mid+1...end
//     int leftPos = start;
//     int rightPos = mid + 1;
//     LinkedList<ArrayValWithOrigIdx> merged = new LinkedList<ArrayValWithOrigIdx>();
//     int numElemsRightArrayLessThanLeftArray = 0;
//     while (leftPos < mid + 1 && rightPos <= end) {
//         if (nums[leftPos].val > nums[rightPos].val) {
//             // this code block is exactly what the problem is asking us for:
//             // a number from the right side of the original input array, is smaller
//             // than a number from the left side
//             //
//             // within this code block,
//             // nums[rightPos] is smaller than the start of the left sub-array.
//             // Since left sub-array is already sorted,
//             // nums[rightPos] must also be smaller than the entire remaining left sub-array
//             ++numElemsRightArrayLessThanLeftArray;
        
//             // continue with normal merge sort, merge
//             merged.add(nums[rightPos]);
//             ++rightPos;
//         } else {
//             // a number from left side of array, is smaller than a number from
//             // right side of array
//             result[nums[leftPos].originalIdx] += numElemsRightArrayLessThanLeftArray;
            
//             // Continue with normal merge sort
//             merged.add(nums[leftPos]);
//             ++leftPos;
//         }
//     }
    
//     // part of normal merge sort, if either left or right sub-array is not empty,
//     // move all remaining elements into merged result
//     while (leftPos < mid + 1) {
//         result[nums[leftPos].originalIdx] += numElemsRightArrayLessThanLeftArray;

//         merged.add(nums[leftPos]);
//         ++leftPos;
//     }
//     while (rightPos <= end) {
//         merged.add(nums[rightPos]);
//         ++rightPos;
//     }
    
//     // part of normal merge sort
//     // copy back merged result into array
//     int pos = start;
//     for (ArrayValWithOrigIdx m : merged) {
//         nums[pos] = m;
//         ++pos;
//     }
// }